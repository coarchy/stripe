<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">
    <service verb="create" noun="CheckoutFromOrder">
        <description>Create a Stripe Checkout Session from an Order to capture a Payment. Customer party not required.

Only one Order Part is supported so that the customer party is clear.</description>
        <in-parameters>
            <parameter name="paymentGatewayConfigId" required="true"/>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId"/>
            <parameter name="customerPartyId" default="ec.user.userAccount?.partyId"/>
            <parameter name="successUrl" required="true" default-value="${ec.web.getWebappRootUrl(false,true)}"/>
        </in-parameters>
        <out-parameters>
            <parameter name="checkoutId"/>
            <parameter name="checkoutUrl"/>
            <parameter name="stripePaymentMethodConfigurationId"/>
        </out-parameters>
        <actions>
            <!-- TODO: Handle ProductStores as a configuration for paymentGatewayConfig? -->
            <entity-find entity-name="mantle.order.OrderHeaderAndPart" list="existingOrderList" limit="2">
                <econdition field-name="orderId"/>
                <econdition field-name="customerPartyId" ignore="!customerPartyId"/>
                <order-by field-name="-entryDate"/></entity-find>
<!--            <script>-->
<!--                def existingOrderListFind = ec.entity.find("mantle.order.OrderHeaderAndPart").condition("orderId", orderId)-->
<!--                        .condition("customerPartyId", customerPartyId)-->
<!--                        .condition(EntityConditionFactory.makeActionCondition("customerPartyId", "equals", null, customerPartyId, null, false, true, false, null))-->
<!--                context.existingOrderList = existingOrderListFind.list()-->
<!--            </script>-->
<!--            <log level="warn" message="existingOrderListFind: ${existingOrderListFind.sqlTopLevel}"/>-->
<!--            <log level="warn" message="existingOrderList: ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(existingOrderList))}"/>-->
            <if condition="!existingOrderList.getFirst()">
                <return error="true" type="danger" message="No order found for orderId ${orderId}."/>
            </if>
            <if condition="existingOrderList.size() &gt;= 2">
                <return error="true" type="danger" message="Cannot have multiple order parts for the customer party (party is optional)"/>
            </if>

            <set field="orderHeaderAndPart" from="existingOrderList.getFirst()"/>

            <!-- TODO: If checkoutId already exists, update the checkout with the new order -->
            <!-- payment_intent_data:[setup_future_usage:'off_session'],payment_method_data:[allow_redisplay:'always'],saved_payment_method_options:[allow_redisplay_filters:'always'] -->
            <set field="stripeMap" from="[success_url:successUrl,mode:'payment',line_items:[],
                customer_creation:'always',payment_intent_data:[setup_future_usage:'off_session']
            ]"/>
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId"/>
                <econdition field-name="orderPartSeqId" ignore-if-empty="true"/>
                <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                <econdition field-name="parentItemSeqId" operator="is-null"/>
                <order-by field-name="orderPartSeqId,orderItemSeqId"/>
                <!-- NOTE: quite a few fields always selected, necessary for calculated values, etc -->
                <!-- just select all by not specifying any fields to select:
                <select-field field-name="orderId,orderItemSeqId,orderPartSeqId,parentItemSeqId,itemTypeEnumId,productId"/>
                <select-field field-name="quantity,selectedAmount,unitAmount,unitListPrice,isPromo"/>
                -->
            </entity-find>
            <set field="topItemSeqIds" from="orderItemList*.orderItemSeqId"/>
            <if condition="topItemSeqIds">
                <entity-find entity-name="mantle.order.OrderItem" list="childOrderItemList">
                    <econdition field-name="orderId"/>
                    <econdition field-name="orderPartSeqId" ignore-if-empty="true"/>
                    <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                    <econdition field-name="parentItemSeqId" operator="in" from="topItemSeqIds"/>
                    <order-by field-name="orderItemSeqId"/>
                </entity-find>
                <set field="orderPartIdDoneList" from="[]"/>
                <script><![CDATA[
                    // NOTE: must use orderItemList.size() on each iteration as EntityList size will change with child items added
                    for (int oiIdx = 0; oiIdx < orderItemList.size(); oiIdx++) {
                        context.orderItem = (Map) orderItemList.get(oiIdx)
                        String orderItemSeqId = orderItem.orderItemSeqId
                        List childList = childOrderItemList.findAll({ orderItemSeqId.equals(it.parentItemSeqId) })
                        Map<String, Object> orderItemTotalOut = ec.service.sync().name("mantle.order.OrderServices.get#OrderItemTotal")
                                .parameters([orderItem:orderItem, getChildrenTotals:false]).call()
                        stripeMap.line_items.addAll([quantity:(Integer)orderItemTotalOut.combinedQuantity,price_data:
                                [currency:'usd',unit_amount_decimal:orderItemTotalOut.combinedAmount*100,product_data:
                                        [name:orderItem.itemDescription]]])
                        for (int cIdx = 0; cIdx < childList.size(); cIdx++) {
                            Map childItem = (Map) childList.get(cIdx)
                            oiIdx++
                            Map<String, Object> childItemTotalOut = ec.service.sync().name("mantle.order.OrderServices.get#OrderItemTotal")
                                    .parameters([orderItem:childItem, getChildrenTotals:false]).call()
                            stripeMap.line_items.addAll([quantity:(Integer)childItemTotalOut.combinedQuantity,price_data:
                                    [currency:'usd',unit_amount_decimal:childItemTotalOut.combinedAmount*100,product_data:
                                            [name:childItem.itemDescription]]])
                        }
                    }
                    ]]></script>
            </if>

<!--            <log level="warn" message="stripeMap.line_items.collect { it.quantity * it.price_data.unit_amount_decimal }: ${stripeMap.line_items.collect { it.quantity * it.price_data.unit_amount_decimal }[0]} orderHeaderAndPart.partTotal*100: ${orderHeaderAndPart.partTotal*100}"/>-->
            <if condition="stripeMap.line_items.collect { it.quantity * it.price_data.unit_amount_decimal }[0] != orderHeaderAndPart.partTotal*100">
                <return error="true" type="danger" message="The sum of the line items does not equal the order part total."/>
            </if>

            <!--            <log level="warn" message="stripeMap: ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(stripeMap))}"/>-->
            <set field="stripeOutMap" from="flattenNestedMapWithKeys(stripeMap)"/>
            <!--            <log level="warn" message="stripeOutMap: ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(stripeOutMap))}"/>-->

            <entity-find-one entity-name="mantle.account.method.PaymentGatewayConfig" value-field="paymentGateway" auto-field-map="[paymentGatewayConfigId:paymentGatewayConfigId]"/>
            <set field="stripeRemote" from="paymentGateway.remote"/>

            <script>import org.moqui.util.RestClient</script>
            <script><![CDATA[
                org.moqui.util.RestClient customerRestClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .basicAuth(stripeRemote.privateKey,"")
                        .addBodyParameters(stripeOutMap)
                def customerUriBuilder = customerRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                        .path("/v1/checkout/sessions")
                customerUriBuilder.build()

                org.moqui.util.RestClient.RestResponse customerRestResponse = customerRestClient.call()
                context.customerResponseMap = (Map) customerRestResponse.jsonObject()
                if (customerRestResponse.statusCode < 200 || customerRestResponse.statusCode >= 300) {
                    ec.logger.warn("Got status code ${customerRestResponse.statusCode} from Stripe on a create checkout session for the parameter '${customerResponseMap.error.type}' and message '${customerResponseMap.error.message}'")
                    ec.logger.warn("Could not create Checkout")
                    ec.message.addPublic("There has been a critical error. Contact support at support@thebizapi.com",null)
                    return
                }
                ]]></script>
            <set field="checkoutId" from="customerResponseMap.id"/>
            <set field="checkoutUrl" from="customerResponseMap.url"/>
            <set field="stripePaymentMethodConfigurationId" from="customerResponseMap.payment_method_configuration_details.id"/>

            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" auto-field-map="[orderId:orderId,
                orderPartSeqId:orderHeaderAndPart.orderPartSeqId]" for-update="true"/>
            <if condition="!orderPart">
                <return error="true" type="danger" message="Unable to save checkout information. No order part found for order ${orderId} order part ${orderHeaderAndPart.orderPartSeqId}."/>
            </if>
            <set field="orderPart.checkoutId" from="checkoutId"/>
            <set field="orderPart.checkoutUrl" from="checkoutUrl"/>
        </actions>
    </service>
<!-- Not tested and partially done    <service verb="create" noun="CheckoutFromPayment">
        <description>Create a Stripe Checkout Session to capture a Payment.

If the payment has an OrderPart with OrderItems attached, the OrderItems will be listed (including discounts and taxes [if setup]).

Otherwise, the payment unapplied total will be listed.</description>
        <in-parameters>
            <parameter name="paymentId" required="true"/>
            <parameter name="successUrl" required="true" default-value="${ec.web.getWebappRootUrl(false,true)}"/>
        </in-parameters>
        <out-parameters>

        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" auto-field-map="[
                paymentId:paymentId]"/>
            <if condition="!payment">
                <return error="true" type="danger" message="No payment found for paymentId ${paymentId}."/>
            </if>
            <entity-find-one entity-name="mantle.account.method.PaymentGatewayConfig" value-field="paymentGateway"
                    auto-field-map="[paymentGatewayConfigId:payment.paymentGatewayConfigId]" cache="true"/>
            <if condition="!paymentGateway">
                <return error="true" type="danger" message="No payment gateway found for paymentId ${paymentId}."/>
            </if>

            <set field="stripeMap" from="[success_url:successUrl,mode:'payment',line_items:[]]"/>
            <if condition="payment.orderId"><then>
                <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                    <econdition field-name="orderId" from="payment.orderId"/>
                    <econdition field-name="orderPartSeqId" from="payment.orderPartSeqId" ignore-if-empty="true"/>
                    <econdition field-name="orderItemSeqId" from="payment.orderItemSeqId" ignore-if-empty="true"/>
                    <econdition field-name="parentItemSeqId" operator="is-null"/>
                    <order-by field-name="orderPartSeqId,orderItemSeqId"/>
                    --><!-- NOTE: quite a few fields always selected, necessary for calculated values, etc -->
                    <!-- just select all by not specifying any fields to select:
                    <select-field field-name="orderId,orderItemSeqId,orderPartSeqId,parentItemSeqId,itemTypeEnumId,productId"/>
                    <select-field field-name="quantity,selectedAmount,unitAmount,unitListPrice,isPromo"/>
                    --><!--
                </entity-find>
                <set field="topItemSeqIds" from="orderItemList*.orderItemSeqId"/>
                <if condition="topItemSeqIds">
                    <entity-find entity-name="mantle.order.OrderItem" list="childOrderItemList">
                        <econdition field-name="orderId" from="payment.orderId"/>
                        <econdition field-name="orderPartSeqId" from="payment.orderPartSeqId" ignore-if-empty="true"/>
                        <econdition field-name="orderItemSeqId" from="payment.orderItemSeqId" ignore-if-empty="true"/>
                        <econdition field-name="parentItemSeqId" operator="in" from="topItemSeqIds"/>
                        <order-by field-name="orderItemSeqId"/>
                    </entity-find>
                    <set field="orderPartIdDoneList" from="[]"/>
                    <script><![CDATA[
                        // NOTE: must use orderItemList.size() on each iteration as EntityList size will change with child items added
                        for (int oiIdx = 0; oiIdx < orderItemList.size(); oiIdx++) {
                            context.orderItem = (Map) orderItemList.get(oiIdx)
                            String orderItemSeqId = orderItem.orderItemSeqId
                            List childList = childOrderItemList.findAll({ orderItemSeqId.equals(it.parentItemSeqId) })
                            Map<String, Object> orderItemTotalOut = ec.service.sync.name("mantle.order.OrderServices.get#OrderItemTotal")
                                .parameters([orderItem:orderItem, getChildrenTotals:false]).call()
                            stripeMap.line_items.addAll([quantity:(Integer)orderItemTotalOut.combinedQuantity,price_data:
                                    [currency:'usd',unit_amount_decimal:orderItemTotalOut.combinedAmount*100,product_data:
                                            [name:orderItem.itemDescription]]])
                            for (int cIdx = 0; cIdx < childList.size(); cIdx++) {
                                Map childItem = (Map) childList.get(cIdx)
                                oiIdx++
                                Map<String, Object> childItemTotalOut = ec.service.sync.name("mantle.order.OrderServices.get#OrderItemTotal")
                                    .parameters([orderItem:childItem, getChildrenTotals:false]).call()
                                stripeMap.line_items.addAll([quantity:(Integer)childItemTotalOut.combinedQuantity,price_data:
                                        [currency:'usd',unit_amount_decimal:childItemTotalOut.combinedAmount*100,product_data:
                                                [name:childItem.itemDescription]]])
                            }
                        }
                        ]]></script>

                </if>
            </then><else>
                <set field="stripeMap.line_items" from="stripeMap.line_items + [quantity:1,price_data:
                                        [currency:payment.amountUomId.toLowerCase(),unit_amount_decimal:payment.unappliedTotal*100,product_data:
                                                [name:payment.comments ?: 'Payment ${paymentId}']]]"/>
            </else></if>

            <if condition="stripeMap.line_items*.unit_amount_decimal.sum() != payment.unappliedTotal*100">
                <return error="true" type="danger" message="The sum of the line items does not match the payment unapplied total."/>
            </if>

--><!--            <log level="warn" message="stripeMap: ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(stripeMap))}"/>-->
<!--            <set field="stripeOutMap" from="flattenNestedMapWithKeys(stripeMap)"/>-->
<!--            <log level="warn" message="stripeOutMap: ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(stripeOutMap))}"/>--><!--

            <entity-find-one entity-name="mantle.account.method.PaymentGatewayConfig" value-field="paymentGateway" auto-field-map="[paymentGatewayConfigId:paymentGatewayConfigId]"/>
            <set field="stripeRemote" from="paymentGateway.remote"/>

            <script>import org.moqui.util.RestClient</script>
            <script><![CDATA[
                org.moqui.util.RestClient customerRestClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .basicAuth(stripeRemote.privateKey,"")
                        .addBodyParameters(stripeOutMap)
                def customerUriBuilder = customerRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                        .path("/v1/checkout/sessions")
                customerUriBuilder.build()

                org.moqui.util.RestClient.RestResponse customerRestResponse = customerRestClient.call()
                customerResponseMap = (Map) customerRestResponse.jsonObject()
                ec.logger.warn("customerResponseMap: ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(customerResponseMap))}")
//                if (customerRestResponse.statusCode < 200 || customerRestResponse.statusCode >= 300) {
//                    ec.logger.warn("Got status code ${customerRestResponse.statusCode} from Stripe on a create customers request for the parameter '${customerResponseMap.error.type}' and message '${customerResponseMap.error.message}'")
//                    ec.logger.warn("Could not create Customer")
//                    ec.message.addPublic(ec.resource.expand('CoarchyOrgPaymentFailed', null), "warning")
//                    return
//                }
                ]]></script>

        </actions>
    </service>-->

    <service verb="create" noun="PaymentIntent">
        <out-parameters>
            <parameter name="clientSecret"/>
            <parameter name="paymentId"/>
        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.order.OrderHeaderAndPart" list="existingOrderList" limit="2">
                <econdition field-name="statusId" value="OrderOpen"/>
                <econdition field-name="customerPartyId" from="ec.user.userAccount.partyId"/>
                <select-field field-name="orderId,orderPartSeqId,grandTotal,currencyUomId,productStoreId"/>
                <order-by field-name="-entryDate"/><!-- get most recent open order --></entity-find>
            <if condition="existingOrderList.size() == 0">
                <log message="No order found for user."/>
                <return error="true" public="true" type="danger"
                    message="${ec.resource.expand('CoarchyInvalidOrder', null)}"/>
            </if>
            <if condition="existingOrderList.size() &gt; 1">
                <log level="warn" message="Multiple open orders or parts found for user. This should not happen." />
                <!-- <message type="warning">Multiple open orders or parts found for user. This should not happen.</message> -->
            </if>

            <set field="orderHeaderAndPart" from="existingOrderList.getFirst()"/>
            <set field="orderId" from="orderHeaderAndPart.orderId"/>

            <entity-find entity-name="mantle.product.store.ProductStorePaymentGateway" list="productStorePaymentGatewayList" limit="1">
                <econdition field-name="productStoreId" from="orderHeaderAndPart.productStoreId"/>
                <econdition field-name="paymentInstrumentEnumId" value="PiStripe"/>
                <econdition field-name="paymentGatewayConfigId" operator="is-not-null"/>
                <select-field field-name="paymentGatewayConfigId"/><order-by field-name="-lastUpdatedStamp"/></entity-find>
            <if condition="productStorePaymentGatewayList.size() == 0">
                <log level="warn" message="No payment gateway found for order." />
                <return error="true" public="true" type="danger"
                    message="${ec.resource.expand('CoarchyOrgPaymentGatewayUnavailable', null)}"/>
            </if>

            <set field="paymentGatewayConfigId" from="productStorePaymentGatewayList.getFirst().paymentGatewayConfigId"/>

            <entity-find entity-name="mantle.account.payment.Payment" list="existingPaymentList">
                <econdition field-name="orderId"/>
                <econdition field-name="orderPartSeqId" from="orderHeaderAndPart.orderPartSeqId"/>
                <econdition field-name="paymentGatewayConfigId"/>
                <select-field field-name="paymentId,amountUomId,unappliedTotal,statusId"/>
                <order-by field-name="-paymentDate"/></entity-find>
<!--            <log level="warn" message="create#PaymentIntent existingPaymentList.toString(): ${existingPaymentList.toString()}"/>-->
            <iterate list="existingPaymentList" entry="existingPayment">
                <if condition="['PmntProposed','PmntPromised'].contains(existingPayment.statusId)">
                    <then>
                        <service-call name="mantle.account.PaymentServices.cancel#PaymentAndInvoices" in-map="[paymentId:existingPayment.paymentId]"/>
                    </then>
                    <else-if condition="['PmntAuthorized','PmntDelivered'].contains(existingPayment.statusId)">
                        <service-call name="mantle.account.PaymentServices.void#Payment" in-map="[paymentId:existingPayment.paymentId]"/>
                    </else-if>
                </if>
            </iterate>

            <service-call name="mantle.order.OrderServices.add#OrderPartPayment" in-map="[orderId:orderHeaderAndPart.orderId,
                orderPartSeqId:orderHeaderAndPart.orderPartSeqId,settlementTermId:'Immediate', paymentInstrumentEnumId:'PiStripe',
                paymentGatewayConfigId:paymentGatewayConfigId,
                entryDate:ec.user.nowTimestamp]" out-map="context"/>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" auto-field-map="[paymentId:paymentId]"/>

            <!-- convert unappliedTotal to cents -->
            <set field="unappliedTotal" from="(payment.unappliedTotal * 100).toInteger()" type="Integer"/>
            <set field="currencyUomId" from="payment.amountUomId"/>

            <!-- System steps -->
            <entity-find-one entity-name="mantle.account.method.PaymentGatewayConfig" value-field="paymentGateway" auto-field-map="[paymentGatewayConfigId:paymentGatewayConfigId]"/>
            <set field="stripeRemote" from="paymentGateway.remote"/>
            <script><![CDATA[party = ec.entity.find("mantle.party.Party").condition("partyId", ec.user.userAccount.partyId).one()]]></script>

            <script>import org.moqui.util.RestClient</script>

            <if condition="!party.externalId">
                <script><![CDATA[
                org.moqui.util.RestClient customerRestClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .basicAuth(stripeRemote.privateKey,"")
                        .addBodyParameter("email", (String) ec.user.userAccount.emailAddress)
                def customerUriBuilder = customerRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                        .path("/v1/customers")
                customerUriBuilder.build()

                org.moqui.util.RestClient.RestResponse customerRestResponse = customerRestClient.call()
                customerResponseMap = (Map) customerRestResponse.jsonObject()
//                ec.logger.warn("customerResponseMap: ${customerResponseMap}")
                if (customerRestResponse.statusCode < 200 || customerRestResponse.statusCode >= 300) {
                    ec.logger.warn("Got status code ${customerRestResponse.statusCode} from Stripe on a create customers request for the parameter '${customerResponseMap.error.type}' and message '${customerResponseMap.error.message}'")
                    ec.logger.warn("Could not create Customer")
                    ec.message.addPublic(ec.resource.expand('CoarchyOrgPaymentFailed', null), "warning")
                    return
                }
                ]]></script>

                <set field="party.externalId" from="customerResponseMap.id"/>
                <entity-update value-field="party"/>
            </if>

            <!-- TODO: Handle if payments already exists so that it will take the previous payment payment_intent id, and client_secret and update stripe with the new payment amount -->

<!--            <set field="return_url" from="(!'production'.equals(System.getProperty('instance_purpose')) ?-->
<!--                'http://localhost:8080' : 'https://coarchy.com') + '/settings/Order'"/>-->
            <script><![CDATA[
                org.moqui.util.RestClient paymentIntentRestClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .basicAuth(stripeRemote.privateKey,"")
                        .addBodyParameter("customer", (String) party.externalId)
                        .addBodyParameter("amount", (String) unappliedTotal)
                        .addBodyParameter("currency", (String) currencyUomId)
//                        .addBodyParameter("setup_future_usage", "off_session")
//                        .addBodyParameter("confirm", (String) "true")
//                        .addBodyParameter("return_url", (String) return_url)
                if (paymentMethodId != null) {
//                    ec.logger.warn("Adding paymentMethodId: ${paymentMethodId}")
//                    paymentIntentRestClient.addBodyParameter("payment_method", (String) paymentMethodId)
                }
                def paymentIntentUriBuilder = paymentIntentRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                    .path("/v1/payment_intents")
                paymentIntentUriBuilder.build()

                org.moqui.util.RestClient.RestResponse paymentIntentRestResponse = paymentIntentRestClient.call()
                paymentIntentResponseMap = (Map) paymentIntentRestResponse.jsonObject()
//                 ec.logger.warn("paymentIntentResponseMap: ${paymentIntentResponseMap}")
                if (paymentIntentRestResponse.statusCode < 200 || paymentIntentRestResponse.statusCode >= 300) {
                    ec.logger.warn("Got status code ${paymentIntentRestResponse.statusCode} from Stripe on a create payment_intents request for the parameter '${paymentIntentResponseMap.error.param}' and message '${paymentIntentResponseMap.error.message}'")
                    ec.logger.warn("Could not create Payment")
                    ec.message.addPublic(ec.resource.expand('CoarchyOrgPaymentFailed', null), "warning")
                }
                ]]></script>

            <service-call name="update#mantle.account.payment.Payment" in-map="[paymentId:payment.paymentId, paymentRefNum:paymentIntentResponseMap?.id]"/>

            <set field="clientSecret" from="paymentIntentResponseMap.client_secret"/>

            <!--            <log level="warn" message="create#PaymentIntent context.toString(): ${context.toString()}"/>-->
        </actions>
    </service>

    <service verb="consume" noun="StripeWebhookEvent" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage" auto-field-map="[systemMessageId:systemMessageId]" for-update="true"/>

            <entity-find entity-name="mantle.account.method.PaymentGatewayConfig" list="paymentGatewayConfigList" limit="1">
                <econdition field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
                <econdition field-name="paymentGatewayTypeEnumId" value="PgtStripe"/>
                <order-by field-name="-lastUpdatedStamp"/>
            </entity-find>
            <set field="paymentGatewayConfig" from="paymentGatewayConfigList.getFirst()"/>
            <set field="paymentGatewayConfigId" from="paymentGatewayConfig.paymentGatewayConfigId"/>

            <set field="messageObject" from="ec.elastic.jsonToObject(systemMessage.messageText)"/>


            <if condition="messageObject.object == 'event' &amp;&amp; messageObject.data.object.object == 'payment_intent'">
<!--                <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" auto-field-map="[paymentId:payment.paymentId]"/>-->
<!--                <log level="warn" message="handle#Webhook payment.toString() ${payment.toString()}}"/>-->

<!-- Don't do anything. There is nothing to do.                <if condition="messageObject.type == 'payment_intent.processing'">
                    <service-call name="create#mantle.account.method.PaymentGatewayResponse" out-map="context" in-map="[
                          paymentGatewayConfigId:paymentGatewayConfigId,
                          paymentOperationEnumId:'PgoStoreCim',
                          paymentId:payment.paymentId,
                          paymentMethodId:payment.paymentMethodId,
                          amount: (messageObject.data.object.amount as BigDecimal) / 100,
                          amountUomId:messageObject.data.object.currency.toUpperCase(),
                          finAccountId:payment.finAccountId,
                          transactionDate:new Timestamp(messageObject.data.object.created * 1000L),
                          referenceNum:messageObject.data.object.id,
                          altReference:messageObject.request.idempotency_key,
                          subReference:messageObject.id,
                          resultSuccess:'N',
                          resultDeclined:'N',
                          resultError:'N',
                          resultBadExpire:'N',
                          resultBadCardNumber:'N']"/>
                </if>-->
                <!-- This event is considered when the payment is authorized and captured -->
                <if condition="messageObject.type == 'payment_intent.succeeded'">
                    <log level="warn" message="handle#Webhook messageObject.toString() ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(messageObject))}"/>

                    <!--                    <log level="warn" message="handle#Webhook messageObject.data.object.amount ${(messageObject.data.object.amount as BigDecimal)} : ${(messageObject.data.object.amount as BigDecimal).getClass()}}"/>-->
                    <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                        <econdition field-name="paymentRefNum" from="messageObject.data.object.id"/>
                    </entity-find>
                    <!--                <log level="warn" message="handle#Webhook paymentList.toString() ${paymentList.toString()}}"/>-->

                    <if condition="paymentList.size() == 0">
                        <!-- Create a payment, customer, and payment method -->
                        <set field="payment_method" from="messageObject.data.object.payment_method"/>
                        <if condition="!payment_method">
                            <return error="true" type="danger" message="No payment method found gatewayCimId ${payment_method}."/>
                        </if>
                        <script><![CDATA[
                            org.moqui.util.RestClient paymentMethodRestClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                                    .basicAuth(systemMessage.remote.privateKey,"")
                            def paymentMethodUriBuilder = paymentMethodRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                                    .path("/v1/payment_methods/${payment_method}")
                            paymentMethodUriBuilder.build()

                            org.moqui.util.RestClient.RestResponse paymentMethodRestResponse = paymentMethodRestClient.call()
                            context.paymentMethodResponseMap = (Map) paymentMethodRestResponse.jsonObject()
                            if (paymentMethodRestResponse.statusCode < 200 || paymentMethodRestResponse.statusCode >= 300) {
                                ec.logger.warn("Got status code ${paymentMethodRestResponse.statusCode} from Stripe on get payment method for the parameter '${paymentMethodResponseMap.error.type}' and message '${paymentMethodResponseMap.error.message}'")
                                ec.logger.warn("Could not get payment method")
                                ec.message.addPublic("There has been a critical error. Contact support at support@thebizapi.com",null)
                                return
                            }
                            ]]></script>
                        <log level="warn" message="handle#Webhook paymentMethodResponseMap ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(paymentMethodResponseMap))}"/>

                        <!-- RIP: https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/ -->
                        <!-- TODO: Consider using https://github.com/tupilabs/HumanNameParser.java/tree/master or something like: https://www.nameapi.org/en/demos/name-parser/ -->
                        <set field="fullName" from="paymentMethodResponseMap.billing_details.name"/>
                        <set field="matcher" from="(fullName =~ /(\S+)\s+(.*)/)"/>
                        <if condition="matcher.matches()">
                            <set field="firstName" from="matcher[0][1] ?: fullName"/>
                            <set field="lastName" from="matcher[0][2] ?: fullName"/>
                        </if>
                        <entity-find entity-name="moqui.basic.Geo" list="countryGeoList" limit="1" cache="true">
                            <econdition field-name="geoCodeAlpha2" from="paymentMethodResponseMap.billing_details.address.country"/>
                        </entity-find>
                        <service-call name="mantle.party.PartyServices.create#PersonCustomer" in-map="[createUserAccount:false,
                            emailAddress:paymentMethodResponseMap.billing_details.email,
                            firstName:firstName,
                            lastName:lastName,
                            toName:paymentMethodResponseMap.billing_details.name,

                            city:paymentMethodResponseMap.billing_details.address.city,
                            countryGeoId:countryGeoList?.getFirst()?.geoId,
                            address1:paymentMethodResponseMap.billing_details.address.line1,
                            address2:paymentMethodResponseMap.billing_details.address.line2,
                            postalCode:paymentMethodResponseMap.billing_details.address.postal_code,
                            stateProvinceGeoId:paymentMethodResponseMap.billing_details.address.state,

                            expireMonth:paymentMethodResponseMap.card.exp_month,
                            expireYear:paymentMethodResponseMap.card.exp_year,
                            cardNumberLookupHash:paymentMethodResponseMap.card.fingerprint,
                            fromDate:new Timestamp(System.currentTimeMillis()),
                            paymentGatewayConfigId:paymentGatewayConfigId,
                            gatewayCimId:paymentMethodResponseMap.id
                        ]" out-map="context"/>

<!--                        <service-call name="mantle.order.OrderServices.add#OrderPartPayment" in-map="[orderId:orderHeaderAndPart.orderId,-->
<!--                            orderPartSeqId:orderHeaderAndPart.orderPartSeqId,settlementTermId:'Immediate', paymentInstrumentEnumId:'PiStripe',-->
<!--                            paymentGatewayConfigId:paymentGatewayConfigId,-->
<!--                            entryDate:ec.user.nowTimestamp]" out-map="context"/>-->
<!--                        <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" auto-field-map="[paymentId:paymentId]"/>-->
                    </if>
                    <if condition="paymentList.size() &gt; 1"><message type="warning">Multiple payments found for paymentRefNum ${messageObject.data.object.id}. This should not happen.</message></if>


                    <!--                <log level="warn" message="handle#Webhook messageObject.type ${messageObject.type}}"/>-->
                    <set field="payment" from="paymentList.getFirst()"/>

                    <!--
                                        <if condition="!payment?.paymentMethodId">
<entity-find entity-name="mantle.account.method.PaymentMethod" list="paymentMethodList" for-update="true">
                        <econdition field-name="ownerPartyId" from="payment.fromPartyId"/>
                        <econdition field-name="gatewayCimId" from="messageObject.data.object.payment_method"/>
                        <econdition field-name="paymentGatewayConfigId"/>
                        <date-filter/></entity-find>
                    <if condition="paymentMethodList.size() == 0"><then>
                        <service-call name="create#mantle.account.method.PaymentMethod" out-map="context" in-map="[
                        ownerPartyId:payment.fromPartyId,fromDate:ec.user.nowTimestamp,
                        currencyUomId:messageObject.data.object.currency.toUpperCase(),
                        gatewayCimId:messageObject.data.object.payment_method,
                        paymentGatewayConfigId:paymentGatewayConfigId]"/>
                        <set field="payment.paymentMethodId" from="paymentMethodId"/>
                    </then><else>
                        <if condition="paymentMethodList.size() &gt; 1">
                            <message type="warning">Multiple payment methods found for ownerPartyId ${payment.fromPartyId}, paymentGatewayConfigId ${paymentGatewayConfigId}, and gatewayCimId ${messageObject.data.object.payment_method}.</message></if>
                        <service-call name="update#mantle.account.method.PaymentMethod" in-map="[
                        paymentMethodId:paymentMethodList.getFirst().paymentMethodId,
                        ownerPartyId:payment.fromPartyId,fromDate:ec.user.nowTimestamp,
                        currencyUomId:messageObject.data.object.currency.toUpperCase(),
                        gatewayCimId:messageObject.data.object.payment_method,
                        paymentGatewayConfigId:paymentGatewayConfigId]"/>
                        <set field="payment.paymentMethodId" from="paymentMethodList.getFirst().paymentMethodId"/>
                    </else></if>
                    <log level="warn" message="handle#Webhook payment.paymentMethodId ${payment.paymentMethodId}"/>
                    <service-call name="update#mantle.account.payment.Payment" in-map="[paymentId:payment.paymentId,
                    paymentMethodId:payment.paymentMethodId]"/>
                    </if>-->


<!--                    <service-call name="create#mantle.account.method.PaymentGatewayResponse" out-map="context" in-map="[-->
<!--                          paymentGatewayConfigId:paymentGatewayConfigId,-->
<!--                          paymentOperationEnumId:'PgoAuthAndCapture',-->
<!--                          paymentId:payment?.paymentId,-->
<!--                          paymentMethodId:payment?.paymentMethodId,-->
<!--                          amount: (messageObject?.data?.object?.amount as BigDecimal) / 100,-->
<!--                          amountUomId:messageObject?.data?.object?.currency?.toUpperCase(),-->
<!--                          finAccountId:payment.finAccountId,-->
<!--                          transactionDate:new Timestamp(messageObject?.data?.object?.created * 1000L),-->
<!--                          referenceNum:messageObject?.data?.object?.id,-->
<!--                          altReference:messageObject?.request?.idempotency_key,-->
<!--                          subReference:messageObject?.id,-->
<!--                          resultSuccess:'Y',-->
<!--                          resultDeclined:'N',-->
<!--                          resultError:'N',-->
<!--                          resultBadExpire:'N',-->
<!--                          resultBadCardNumber:'N']"/>-->

<!--                    <service-call name="mantle.order.OrderServices.place#Order" in-map="[orderId:payment.orderId]"/>-->
                </if>
                <if condition="messageObject.type == 'payment_intent.payment_failed'">
                    <service-call name="create#mantle.account.method.PaymentGatewayResponse" out-map="context" in-map="[
                          paymentGatewayConfigId:paymentGatewayConfigId,
                          paymentOperationEnumId:'PgoRelease',
                          paymentId:payment.paymentId,
                          paymentMethodId:payment.paymentMethodId,
                          amount: (messageObject.data.object.amount as BigDecimal) / 100,
                          amountUomId:messageObject.data.object.currency.toUpperCase(),
                          finAccountId:payment.finAccountId,
                          transactionDate:new Timestamp(messageObject.data.object.created * 1000L),
                          referenceNum:messageObject.data.object.id,
                          altReference:messageObject.request.idempotency_key,
                          subReference:messageObject.id,
                          resultSuccess:'N',
                          resultDeclined:'Y',
                          resultError:'N',
                          resultBadExpire:'N',
                          resultBadCardNumber:'N']"/>
                </if>
            </if>
        </actions>
    </service>

    <service verb="authorizeAndCapture" noun="Payment">
        <implements service="mantle.account.PaymentServices.authorize#Payment"/>
        <actions>
            <entity-find entity-name="mantle.account.method.PaymentGatewayResponse" list="paymentGatewayResponseList">
                <econdition field-name="paymentId"/>
                <econdition field-name="paymentGatewayConfigId"/>
                <econdition field-name="paymentOperationEnumId" value="PgoAuthAndCapture"/>
                <order-by field-name="-transactionDate"/></entity-find>

            <if condition="paymentGatewayResponseList.size() == 0">
                <return error="true" type="danger" message="No payment gateway response found for payment."/>
            </if>
            <if condition="paymentGatewayResponseList.size() &gt; 1">
                <log level="warn" message="Multiple payment gateway responses found for payment."/>
            </if>

            <set field="paymentGatewayResponseId" from="paymentGatewayResponseList.getFirst().paymentGatewayResponseId"/>
        </actions>
    </service>

</services>
