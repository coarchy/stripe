<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">
    <service verb="create" noun="CheckoutFromSalesOrder">
        <description>Create a Stripe Checkout Session from an Order to capture a Payment. Customer party not required.
Will return a used checkoutId and checkoutUrl if the OrderPart has already created a checkout session with the same orderItems, quantities, and prices.

Only one Order Part is supported so that the customer party is clear.</description>
        <in-parameters>
            <parameter name="paymentGatewayConfigId" required="true"/>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId"/>
            <parameter name="customerPartyId" default="ec.user.userAccount?.partyId"/>
            <parameter name="successUrl" required="true" default-value="${ec.web?.getWebappRootUrl(false,true)}"></parameter>
            <parameter name="cancelUrl" required="true" default-value="${ec.web?.getWebappRootUrl(false,true)}"></parameter>
            <parameter name="setup_future_usage" required="true" default-value="on_session"><description>
                Setup future usage for the PaymentIntent. One of on_session or off_session. Default is on_session. See: https://docs.stripe.com/api/checkout/sessions/create#create_checkout_session-payment_intent_data-setup_future_usage
            </description></parameter>
        </in-parameters>
        <out-parameters>
            <parameter name="checkoutId"/>
            <parameter name="checkoutUrl"/>
            <parameter name="customer" default="null"/>
<!-- This doesn't work as far as I can tell            <parameter name="customer"><description>Stripe customer Id. Can be used by guest checkout to find the partyId from PartyIdentification's idValue with a partyIdTypeEnumId of PtidSci and valid expireDate.</description></parameter>-->
        </out-parameters>
        <actions>
            <!-- TODO: Handle ProductStores as a configuration for paymentGatewayConfig? -->
            <entity-find entity-name="mantle.order.OrderHeaderAndPart" list="existingOrderList" limit="2">
                <econdition field-name="orderId"/>
                <econdition field-name="orderPartSeqId" ignore="!orderPartSeqId"/>
                <econdition field-name="customerPartyId" ignore="!customerPartyId"/>
                <order-by field-name="-entryDate"/></entity-find>
            <if condition="!existingOrderList.getFirst()">
                <return error="true" type="danger" message="No order found for orderId ${orderId}."/>
            </if>
            <if condition="existingOrderList.size() &gt;= 2">
                <return error="true" type="danger" message="Cannot have multiple order parts for the customer party (party is optional)"/>
            </if>

            <set field="orderHeaderAndPart" from="existingOrderList.getFirst()"/>
            <if condition="!orderHeaderAndPart.vendorPartyId">
                <return error="true" type="danger" message="Must have an vendorPartyId that is has an OrgInternal PartyRole for orderPart ${orderHeaderAndPart.orderPartSeqId} on order ${orderHeaderAndPart.orderId}"/>
            </if>
            <entity-find-one entity-name="mantle.party.PartyRole" value-field="partyRole" auto-field-map="[
                partyId:orderHeaderAndPart.vendorPartyId,roleTypeId:'OrgInternal']"/>
            <if condition="!partyRole">
                <return error="true" type="danger" message="Must have an vendorPartyId ${orderHeaderAndPart.vendorPartyId} that is has an OrgInternal PartyRole for orderPart ${orderHeaderAndPart.orderPartSeqId} on order ${orderHeaderAndPart.orderId}"/>
            </if>

            <set field="customer_creation" value="always"/>
            <set field="customer" from="null"/>
            <set field="customer_email" from="null"/>
            <if condition="orderHeaderAndPart.customerPartyId">
                <entity-find entity-name="mantle.party.PartyIdentification" list="partyIdentificationList" limit="1">
                    <econdition field-name="partyId" from="orderHeaderAndPart.customerPartyId"/>
                    <econdition field-name="partyIdTypeEnumId" value="PtidSci"/>
                    <econdition field-name="expireDate" operator="less-equals" from="ec.user.nowTimestamp" or-null="true"/>
                </entity-find>
                <if condition="partyIdentificationList.getFirst()?.idValue">
                    <set field="customer_creation" value="if_required"/>
                    <set field="customer" from="partyIdentificationList.getFirst()?.idValue"/>
                </if>
                <if condition="!customer">
                    <service-call name="mantle.party.ContactServices.get#PartyDefaultBilling"
                            in-map="[partyId:orderHeaderAndPart.customerPartyId]" out-map="context"/>
                    <if condition="emailContactMechId">
                        <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="emailContactMech"
                                auto-field-map="[contactMechId:emailContactMechId]"/>
                        <if condition="emailContactMech.infoString">
                            <set field="customer_creation" value="if_required"/>
                            <set field="customer_email" from="emailContactMech.infoString"/>
                        </if>
                    </if>
                </if>
            </if>

            <!-- payment_method_data:[allow_redisplay:'always'],saved_payment_method_options:[allow_redisplay_filters:'always',payment_method_save:'enabled'] -->
            <set field="stripeMap" from="[success_url:successUrl,cancel_url:cancelUrl,mode:'payment',line_items:[],
                payment_intent_data:[setup_future_usage:setup_future_usage],payment_method_data:[allow_redisplay:'always'],
            ]"/>
            <if condition="customer"><then><set field="stripeMap" from="stripeMap + [customer:customer]"/></then>
            <else-if condition="customer_email">
                <set field="stripeMap" from="stripeMap + [customer_email:customer_email,customer_creation:customer_creation]"/>
            </else-if></if>
            <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                <econdition field-name="orderId"/>
                <econdition field-name="orderPartSeqId" ignore-if-empty="true"/>
                <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                <econdition field-name="parentItemSeqId" operator="is-null"/>
                <order-by field-name="orderPartSeqId,orderItemSeqId"/>
                <!-- NOTE: quite a few fields always selected, necessary for calculated values, etc -->
                <!-- just select all by not specifying any fields to select:
                <select-field field-name="orderId,orderItemSeqId,orderPartSeqId,parentItemSeqId,itemTypeEnumId,productId"/>
                <select-field field-name="quantity,selectedAmount,unitAmount,unitListPrice,isPromo"/>
                -->
            </entity-find>
            <set field="topItemSeqIds" from="orderItemList*.orderItemSeqId"/>
            <set field="currency" from="orderHeaderAndPart.currencyUomId?orderHeaderAndPart.currencyUomId.toLowerCase():'usd'"/>
            <if condition="topItemSeqIds">
                <entity-find entity-name="mantle.order.OrderItem" list="childOrderItemList">
                    <econdition field-name="orderId"/>
                    <econdition field-name="orderPartSeqId" ignore-if-empty="true"/>
                    <econdition field-name="orderItemSeqId" ignore-if-empty="true"/>
                    <econdition field-name="parentItemSeqId" operator="in" from="topItemSeqIds"/>
                    <order-by field-name="orderItemSeqId"/>
                </entity-find>
                <set field="orderPartIdDoneList" from="[]"/>
                <script><![CDATA[
                    // NOTE: must use orderItemList.size() on each iteration as EntityList size will change with child items added
                    for (int oiIdx = 0; oiIdx < orderItemList.size(); oiIdx++) {
                        context.orderItem = (Map) orderItemList.get(oiIdx)
                        String orderItemSeqId = orderItem.orderItemSeqId
                        List childList = childOrderItemList.findAll({ orderItemSeqId.equals(it.parentItemSeqId) })
                        Map<String, Object> orderItemTotalOut = ec.service.sync().name("mantle.order.OrderServices.get#OrderItemTotal")
                                .parameters([orderItem:orderItem, getChildrenTotals:false]).call()
                        stripeMap.line_items.addAll([quantity:(Integer)orderItemTotalOut.combinedQuantity,price_data:
                                [currency:currency,unit_amount_decimal:orderItemTotalOut.combinedAmount*100,product_data:
                                        [name:orderItem.itemDescription]]])
                        for (int cIdx = 0; cIdx < childList.size(); cIdx++) {
                            Map childItem = (Map) childList.get(cIdx)
                            oiIdx++
                            Map<String, Object> childItemTotalOut = ec.service.sync().name("mantle.order.OrderServices.get#OrderItemTotal")
                                    .parameters([orderItem:childItem, getChildrenTotals:false]).call()
                            stripeMap.line_items.addAll([quantity:(Integer)childItemTotalOut.combinedQuantity,price_data:
                                    [currency:currency,unit_amount_decimal:childItemTotalOut.combinedAmount*100,product_data:
                                            [name:childItem.itemDescription]]])
                        }
                    }
                    ]]></script>
            </if>

            <if condition="stripeMap.line_items.size() &gt; 100">
                <return error="true" type="danger" message="Cannot have more than 100 line items. Please combine your line items."/>
            </if>

            <entity-find-one entity-name="mantle.account.method.PaymentGatewayConfig" value-field="paymentGateway" auto-field-map="[paymentGatewayConfigId:paymentGatewayConfigId]"/>
            <if condition="!paymentGateway">
                <return error="true" type="danger" message="No PaymentGatewayConfig found for paymentGatewayConfigId ${paymentGatewayConfigId}"/>
            </if>
            <if condition="paymentGateway.systemMessageRemoteId">
                <entity-find-one entity-name="moqui.service.message.SystemMessageRemote" value-field="stripeRemote" auto-field-map="[systemMessageRemoteId:paymentGateway.systemMessageRemoteId]"/>
            </if>
            <if condition="!stripeRemote">
                <return error="true" type="danger" message="No SystemMessageRemote found for PaymentGatewayConfig ${paymentGatewayConfigId}"/>
            </if>

            <if condition="!stripeRemote.privateKey || !stripeRemote.publicKey || !stripeRemote.sharedSecret">
                <return error="true" type="danger" message="No ${!stripeRemote.privateKey?'private key':''} ${!stripeRemote.publicKey?'public key':''} ${!stripeRemote.sharedSecret?'shared secret':''} found for SystemMessageRemote ${stripeRemote.systemMessageRemoteId}. Go to ${ec.web.getWebappRootUrl(false,true)}/qapps/system/SystemMessage/Remote/MessageRemoteDetail?systemMessageRemoteId=${stripeRemote.systemMessageRemoteId} from https://dashboard.stripe.com/${'production'!=System.getProperty('instance_purpose') ? 'test/' : '' }apikeys"/>
            </if>

            <if condition="orderHeaderAndPart.checkoutId">
                <script><![CDATA[
                    org.moqui.util.RestClient checkoutItemsRestClient = ec.service.rest().method(org.moqui.util.RestClient.GET)
                            .basicAuth(stripeRemote.privateKey,"")
                            .addBodyParameters([limit:stripeMap.line_items.size()+1 as String])
                    def checkoutItemsUriBuilder = checkoutItemsRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                            .path("/v1/checkout/sessions/${orderHeaderAndPart.checkoutId}/line_items")
                    checkoutItemsUriBuilder.build()

                    org.moqui.util.RestClient.RestResponse checkoutItemsRestResponse = checkoutItemsRestClient.call()
                    context.checkoutItemsResponseMap = (Map) checkoutItemsRestResponse.jsonObject()
                    if (checkoutItemsRestResponse.statusCode < 200 || checkoutItemsRestResponse.statusCode >= 300) {
                        ec.logger.warn("Could not create Checkout")
                        throw new org.moqui.BaseException("Got status code ${checkoutItemsRestResponse.statusCode} from Stripe on a create checkout session for the parameter '${checkoutItemsResponseMap.error.type}' and message '${checkoutItemsResponseMap.error.message}'")
                        return
                    }
                    ]]></script>
                <set field="isTheSameOrder" from="stripeMap.line_items.collect { it.quantity * it.price_data.unit_amount_decimal }.sum() == checkoutItemsResponseMap.data.collect { (new BigDecimal(it.quantity)) * (new BigDecimal(it.price.unit_amount_decimal)) }.sum()"/>
                <if condition="isTheSameOrder">
                    <set field="isTheSameOrder" from="checkoutItemsResponseMap.data.price.every{ it.currency == currency }"/>
                </if>
                <if condition="isTheSameOrder"><then>
                    <log message="Found existing checkout session with the same order items, quantities, and prices"/>
                    <set field="checkoutId" from="orderHeaderAndPart.checkoutId"/>
                    <set field="checkoutUrl" from="orderHeaderAndPart.checkoutUrl"/>
                    <return/>
                </then><else>
                    <log message="Cancelling checkout ${orderHeaderAndPart.checkoutId} because existing checkout session has different order items, quantities, or prices"/>
                    <service-call name="stripe.StripeServices.cancel#CheckoutFromSalesOrderPart" in-map="[orderId:orderId,orderPartSeqId:orderHeaderAndPart.orderPartSeqId]"/>
                </else></if>
            </if>

            <!--            <log level="warn" message="stripeMap.line_items.collect { it.quantity * it.price_data.unit_amount_decimal }: ${stripeMap.line_items.collect { it.quantity * it.price_data.unit_amount_decimal }[0]} orderHeaderAndPart.partTotal*100: ${orderHeaderAndPart.partTotal*100}"/>-->
            <set field="stripeMapTotal" from="stripeMap.line_items.collect { it.quantity * it.price_data.unit_amount_decimal }.sum()"/>
            <set field="orderPartTotal" from="orderHeaderAndPart.partTotal*100"/>
            <if condition="stripeMapTotal != orderPartTotal">
                <return error="true" type="danger" message="The sum of the external line items ${ec.l10n.formatCurrency((stripeMapTotal as BigDecimal), orderHeaderAndPart.currencyUomId?:'USD')} does not equal the order part total ${ec.l10n.formatCurrency((orderPartTotal as BigDecimal), orderHeaderAndPart.currencyUomId?:'USD')}."/>
            </if>

            <!--            <log level="warn" message="stripeMap: ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(stripeMap))}"/>-->
            <set field="stripeOutMap" from="flattenNestedMapWithKeys(stripeMap)"/>
            <!--            <log level="warn" message="stripeOutMap: ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(stripeOutMap))}"/>-->

            <script><![CDATA[
                org.moqui.util.RestClient checkoutSessionRestClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .basicAuth(stripeRemote.privateKey,"")
                        .addBodyParameters(stripeOutMap)
                def checkoutSessionUriBuilder = checkoutSessionRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                        .path("/v1/checkout/sessions")
                checkoutSessionUriBuilder.build()

                org.moqui.util.RestClient.RestResponse checkoutSessionRestResponse = checkoutSessionRestClient.call()
                context.checkoutSessionResponseMap = (Map) checkoutSessionRestResponse.jsonObject()
                if (checkoutSessionRestResponse.statusCode < 200 || checkoutSessionRestResponse.statusCode >= 300) {
                    ec.logger.warn("Could not create Checkout")
                    throw new org.moqui.BaseException("Got status code ${checkoutSessionRestResponse.statusCode} from Stripe on a create checkout session for the parameter '${checkoutSessionResponseMap.error.type}' and message '${checkoutSessionResponseMap.error.message}'")
                    return
                }
                ]]></script>
            <set field="checkoutId" from="checkoutSessionResponseMap.id"/>
            <set field="checkoutUrl" from="checkoutSessionResponseMap.url"/>

            <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" auto-field-map="[orderId:orderId,
                orderPartSeqId:orderHeaderAndPart.orderPartSeqId]" for-update="true"/>
            <if condition="!orderPart">
                <return error="true" type="danger" message="Unable to save checkout information. No order part found for order ${orderId} order part ${orderHeaderAndPart.orderPartSeqId}."/>
            </if>
            <set field="orderPart.checkoutId" from="checkoutId"/>
            <set field="orderPart.checkoutUrl" from="checkoutUrl"/>
            <entity-update value-field="orderPart"/>
        </actions>
    </service>

    <service verb="cancel" noun="CheckoutFromSalesOrderPart">
        <description>Called by a seca on update#mantle.order.OrderPart to cancel a checkout session if the order part is cancelled.</description>
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
        </in-parameters>
        <out-parameters>

        </out-parameters>
        <actions>
            <entity-find entity-name="mantle.order.OrderPart" list="existingOrderPartList" limit="2">
                <econdition field-name="orderId"/>
                <econdition field-name="customerPartyId" ignore="!customerPartyId"/>
                <econdition field-name="checkoutId" operator="is-not-null"/>
                <order-by field-name="-entryDate"/></entity-find>
            <if condition="!existingOrderPartList.getFirst()">
                <log level="warn" message="No order found for orderId ${orderId}."/>
                <return message="No order found for orderId ${orderId}."/>
            </if>
            <if condition="existingOrderPartList.size() &gt;= 2">
                <log level="warn" message="Cannot have multiple order parts for the customer party (party is optional)"/>
                <return message="Cannot have multiple order parts for the customer party (party is optional)"/>
            </if>

            <set field="orderPart" from="existingOrderPartList.getFirst()"/>
            <if condition="!orderPart.checkoutId">
                <log level="warn" message="Not cancelling checkout for order ${orderId} order part ${orderPart.orderPartSeqId} as there is no checkoutId."/>
                <return/>
            </if>

            <script><![CDATA[
                org.moqui.util.RestClient cancelCheckoutSessionRestClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .basicAuth(orderPart.orderHeader.productStore.remote.privateKey,"")
                def cancelCheckoutSessionUriBuilder = cancelCheckoutSessionRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                        .path("/v1/checkout/sessions/${orderPart.checkoutId}/expire")
                cancelCheckoutSessionUriBuilder.build()

                org.moqui.util.RestClient.RestResponse cancelCheckoutSessionRestResponse = cancelCheckoutSessionRestClient.call()
                context.cancelCheckoutSessionResponseMap = (Map) cancelCheckoutSessionRestResponse.jsonObject()
                if (cancelCheckoutSessionRestResponse.statusCode < 200 || cancelCheckoutSessionRestResponse.statusCode >= 300) {
                    ec.logger.warn("Could not create Checkout")
                    throw new org.moqui.BaseException("Got status code ${cancelCheckoutSessionRestResponse.statusCode} from Stripe on a create checkout session for the parameter '${cancelCheckoutSessionResponseMap.error.type}' and message '${cancelCheckoutSessionResponseMap.error.message}'")
                    return
                }
                ]]></script>
        </actions>
    </service>

    <service verb="consume" noun="StripeWebhookEvent" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="systemMessageId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="partyId"/>
            <parameter name="paymentId"/>
            <parameter name="paymentMethodId"/>
            <parameter name="postalContactMechId"/>
            <parameter name="telecomContactMechId"/>
            <parameter name="emailContactMechId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="moqui.service.message.SystemMessage" value-field="systemMessage" auto-field-map="[systemMessageId:systemMessageId]" for-update="true"/>

            <entity-find entity-name="mantle.account.method.PaymentGatewayConfig" list="paymentGatewayConfigList" limit="1">
                <econdition field-name="systemMessageRemoteId" from="systemMessage.systemMessageRemoteId"/>
                <order-by field-name="-lastUpdatedStamp"/>
            </entity-find>
            <set field="paymentGatewayConfig" from="paymentGatewayConfigList.getFirst()"/>
            <set field="paymentGatewayConfigId" from="paymentGatewayConfig.paymentGatewayConfigId"/>
            <if condition="paymentGatewayConfig.paymentGatewayTypeEnumId != 'PgtStripe'">
                <log level="warn" message="PaymentGatewayConfig ${paymentGatewayConfigId} is not a PgtStripe gateway"/>
            </if>

            <set field="messageObject" from="ec.elastic.jsonToObject(systemMessage.messageText)"/>

            <if condition="messageObject.object == 'event' &amp;&amp; messageObject.data.object.object == 'checkout.session'">
                <!-- Get order part from checkoutId -->
                <entity-find entity-name="mantle.order.OrderPart" list="orderPartList" limit="2" for-update="true">
                    <econdition field-name="checkoutId" from="messageObject.data.object.id"/>
                    <order-by field-name="-lastUpdatedStamp,orderPartSeqId"/>
                </entity-find>
                <if condition="orderPartList.size() == 0">
                    <return type="warning" message="No order part found for checkoutId ${messageObject.data.object.id}"/>
                </if>
                <if condition="orderPartList.size() &gt;= 2">
                    <log level="warn" message="Multiple order parts found for checkoutId ${messageObject.data.object.id}"/>
                </if>
                <set field="orderPart" from="orderPartList.getFirst()"/>

                <if condition="messageObject.type == 'checkout.session.completed'">
                    <service-call name="stripe.StripeServices.consume#CheckoutSessionCompleted" in-map="context" out-map="context"/>
                </if>

                <if condition="messageObject.type == 'checkout.session.expired'">
                    <service-call name="stripe.StripeServices.consume#CheckoutSessionExpired" in-map="context" out-map="context"/>
                </if>
            </if>
        </actions>
    </service>
    <service verb="consume" noun="StripeWebhookEventInterface">
        <in-parameters>
            <parameter name="systemMessage" type="EntityValue"/>
            <parameter name="paymentGatewayConfig" type="EntityValue"/>
            <parameter name="paymentGatewayConfigId"/>
            <parameter name="messageObject" type="Map"/>
            <parameter name="orderPart" type="EntityValue"/>
        </in-parameters>
        <out-parameters>
            <!-- Use these parameters for sending emails through a tx-commit seca -->
            <parameter name="orderId"/>
            <parameter name="orderPartSeqId"/>
            <parameter name="partyId"/>
            <parameter name="fullName"/>
            <parameter name="firstName"/>
            <parameter name="lastName"/>
            <parameter name="countryGeoId"/>
            <parameter name="address1"/>
            <parameter name="address2"/>
            <parameter name="postalCode"/>
            <parameter name="city"/>
            <parameter name="stateProvinceGeoId"/>
            <parameter name="contactNumber"/>
            <parameter name="emailAddress"/>
            <parameter name="paymentMethodId"/>
            <parameter name="paymentId"/>
            <parameter name="amount" type="BigDecimal"/>
            <parameter name="amountUomId"/>
            <parameter name="transactionDate" type="Timestamp"/>
            <parameter name="referenceNum"/>
            <parameter name="altReference"/>
            <parameter name="subReference"/>
            <parameter name="paymentInstrumentEnumId"/>
        </out-parameters>
    </service>
    <service verb="consume" noun="CheckoutSessionCompleted">
        <implements service="stripe.StripeServices.consume#StripeWebhookEventInterface"/>
        <in-parameters>
            <parameter name="isTest" required="true" default="false"/>

            <parameter name="paymentMethodId"/>
        </in-parameters>
        <actions>
            <!-- Get partyId (required for a payment) -->
            <set field="partyId" from="orderPart.customerPartyId"/>
            <if condition="messageObject.data.object.customer">
                <if condition="partyId"><then>
                    <entity-find-one entity-name="mantle.party.PartyIdentification" value-field="partyIdentification"
                            auto-field-map="[partyId:partyId,partyIdTypeEnumId:'PtidSci']" for-update="true"/>
                    <if condition="partyIdentification?.idValue &amp;&amp; partyIdentification.idValue != messageObject.data.object.customer">
                        <set field="partyIdentification.idValue" from="messageObject.data.object.customer"/>
                        <entity-update value-field="partyIdentification"/>
                    </if>
                    <if condition="partyIdentification &amp;&amp; partyIdentification.expireDate &lt;= new Timestamp(System.currentTimeMillis())">
                        <set field="identificationPartyId" from="partyId"/>
                    </if>
                </then><else>
                    <entity-find entity-name="mantle.party.PartyIdentification" list="partyIdentificationList" limit="1">
                        <econdition field-name="partyIdTypeEnumId" value="PtidSci"/>
                        <econdition field-name="idValue" from="messageObject.data.object.customer"/>
                        <econdition field-name="expireDate" operator="less-equals" from="new Timestamp(System.currentTimeMillis())"/>
                        <order-by field-name="-lastUpdatedStamp"/>
                    </entity-find>
                    <set field="identificationPartyId" from="partyIdentificationList.getFirst()?.partyId"/>
                </else></if>
                <if condition="identificationPartyId &amp;&amp; partyId &amp;&amp; identificationPartyId != partyId">
                    <log level="warn" message="A partyId was found for the customer ${messageObject.data.object.customer} but it is not the same as the orderPart.customerPartyId ${partyId}"/>
                </if>
                <if condition="!partyId &amp;&amp; identificationPartyId">
                    <set field="partyId" from="identificationPartyId"/>
                </if>
                <if condition="partyId &amp;&amp; !identificationPartyId">
                    <service-call name="store#mantle.party.PartyIdentification" in-map="[partyId:partyId,
                        partyIdTypeEnumId:'PtidSci',idValue:messageObject.data.object.customer]"/>
                </if>
            </if>
            <!-- RIP: https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/ -->
            <!-- TODO: Consider using https://github.com/tupilabs/HumanNameParser.java/tree/master or something like: https://www.nameapi.org/en/demos/name-parser/ -->
            <set field="fullName" from="messageObject.data.object.customer_details?.name"/>
            <set field="matcher" from="(fullName =~ /(\S+)\s+(.*)/)"/>
            <if condition="matcher.matches()"><then>
                <set field="firstName" from="matcher[0][1] ?: fullName"/>
                <set field="lastName" from="matcher[0][2] ?: fullName"/>
            </then><else>
                <set field="firstName" from="fullName"/>
                <set field="lastName" from="fullName"/>
            </else></if>
            <if condition="!firstName || !lastName">
                <set field="firstName" value="No"/>
                <set field="lastName" value="Name"/>
            </if>
            <!--                    <log level="warn" message="handle#Webhook fullName ${fullName} firstName ${firstName} lastName ${lastName}"/>-->
            <if condition="messageObject.data.object.customer_details.address?.country">
                <entity-find entity-name="moqui.basic.Geo" list="countryGeoList" limit="1" cache="true">
                    <econdition field-name="geoCodeAlpha2" from="messageObject.data.object.customer_details.address.country"/>
                </entity-find>
            </if>
            <if condition="!partyId">
                <service-call name="mantle.party.PartyServices.create#PersonCustomer" in-map="[createUserAccount:false,
                            emailAddress:messageObject.data.object.customer_details.email,
                            firstName:firstName,
                            lastName:lastName
                        ]" out-map="context"/>
            </if>
            <if condition="!partyId">
                <return error="true" type="danger" message="No party found or able to create for customer."/>
            </if>

            <if condition="!orderPart.customerPartyId">
                <set field="orderPart.customerPartyId" from="partyId"/>
                <entity-update value-field="orderPart"/>
            </if>

            <if condition="!paymentMethodId &amp;&amp; !isTest">
                <if condition="!messageObject.data.object.payment_intent">
                    <!-- TODO: If zero cost product, no payment intent don't error -->
                    <return error="true" type="danger" message="No payment method found for checkout ${messageObject.data.object.id}."/>
                </if>
                <script><![CDATA[
                    org.moqui.util.RestClient paymentIntentRestClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                            .basicAuth(systemMessage.remote.privateKey,"")
                    def paymentIntentUriBuilder = paymentIntentRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                            .path("/v1/payment_intents/${messageObject.data.object.payment_intent}")
                    paymentIntentUriBuilder.build()

                    org.moqui.util.RestClient.RestResponse paymentIntentRestResponse = paymentIntentRestClient.call()
                    context.paymentIntentResponseMap = (Map) paymentIntentRestResponse.jsonObject()
                    if (paymentIntentRestResponse.statusCode < 200 || paymentIntentRestResponse.statusCode >= 300) {
                        ec.logger.warn("Could not get payment intent")
                        throw new org.moqui.BaseException("Got status code ${paymentIntentRestResponse.statusCode} from Stripe on a get payment intent for the parameter '${paymentIntentResponseMap.error.type}' and message '${paymentIntentResponseMap.error.message}'")
                        return
                    }
                    ]]></script>
                <if condition="paymentIntentResponseMap.customer &amp;&amp; messageObject.data.object.customer &amp;&amp; paymentIntentResponseMap.customer != messageObject.data.object.customer">
                    <return type="danger" error="true" message="The customer on the payment intent ${paymentIntentResponseMap.customer} does not match the customer on the checkout session ${messageObject.data.object.customer}."/>
                </if>

                <entity-find entity-name="mantle.account.method.PaymentMethod" list="paymentMethodList" for-update="true">
                    <econdition field-name="ownerPartyId" from="orderPart.customerPartyId"/>
                    <econdition field-name="gatewayCimId" from="paymentIntentResponseMap.payment_method"/>
                    <econdition field-name="paymentGatewayConfigId"/>
                    <date-filter/></entity-find>

                <set field="paymentMethod" from="paymentMethodList.getFirst()"/>
                <set field="paymentMethodId" from="paymentMethod?.paymentMethodId"/>
                <set field="origPaymentMethodId" from="paymentMethodId"/>
                <set field="postalContactMechId" from="paymentMethod?.postalContactMechId"/>
                <set field="telecomContactMechId" from="paymentMethod?.telecomContactMechId"/>
                <set field="emailContactMechId" from="paymentMethod?.emailContactMechId"/>
                <set field="paymentMethodTypeEnumId" value="PmtStripe"/>

                <set field="emailAddress" from="messageObject.data.object.customer_details.email"/>

                <set field="toName" from="messageObject.data.object.customer_details.name"/>
                <set field="city" from="messageObject.data.object.customer_details.address?.city"/>
                <set field="countryGeoId" from="countryGeoList?.getFirst()?.geoId"/>
                <set field="address1" from="messageObject.data.object.customer_details.address?.line1?:' '"/>
                <set field="address2" from="messageObject.data.object.customer_details.address?.line2"/>
                <set field="postalCode" from="messageObject.data.object.customer_details.address?.postal_code"/>
                <set field="stateProvinceGeoId" from="null"/>
                <log level="warn" message="handle#Webhook messageObject.data.object.customer_details?.address?.state ${messageObject.data.object.customer_details?.address?.state}"/>
                <if condition="messageObject.data.object.customer_details.address?.state">
                    <entity-find entity-name="moqui.basic.Geo" list="stateGeoList" cache="true">
                        <econdition field-name="geoCodeAlpha2" from="messageObject.data.object.customer_details.address?.state"/>
                    </entity-find>
                    <if condition="stateGeoList.size() &gt; 1">
                        <then>
                            <entity-find entity-name="moqui.basic.GeoAssoc" list="stateGeoAssocList" cache="true">
                                <econdition field-name="geoId" from="countryGeoId"/>
                                <econdition field-name="toGeoId" operator="in" from="stateGeoList*.geoId"/>
                            </entity-find>
                            <set field="stateProvinceGeoId" from="stateGeoAssocList?.getFirst()?.toGeoId"/>
                        </then>
                        <else>
                            <set field="stateProvinceGeoId" from="stateGeoList?.getFirst()?.geoId"/>
                        </else>
                    </if>
                </if>

                <set field="contactNumber" from="messageObject.data.object.customer_details.phone"/>

                <set field="postalContactMechPurposeId" value="PostalBilling"/>
                <set field="telecomContactMechPurposeId" value="PhoneBilling"/>
                <set field="emailContactMechPurposeId" value="EmailBilling"/>
                <set field="fromDate" from="new Timestamp(System.currentTimeMillis())"/>

                <set field="trustLevelEnumId" value="CmtlVerified"/>

                <if condition="paymentMethodId"><then>
                    <!-- if update (paymentMethodId) and main field for type specified then update it -->
                    <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="context" out-map="context"/>
                </then><else>
                    <!-- if create (!paymentMethodId) and *ContactMechId just use it, otherwise create contact mech -->
                    <if condition="!postalContactMechId &amp;&amp; address1">
                        <service-call name="mantle.party.ContactServices.create#PostalAddress" out-map="paOut"
                                in-map="context + [contactMechPurposeId:postalContactMechPurposeId]"/>
                        <set field="postalContactMechId" from="paOut.contactMechId"/>
                    </if>
                    <if condition="!telecomContactMechId &amp;&amp; contactNumber">
                        <service-call name="mantle.party.ContactServices.create#TelecomNumber" out-map="tnOut"
                                in-map="context + [contactMechPurposeId:telecomContactMechPurposeId]"/>
                        <set field="telecomContactMechId" from="tnOut.contactMechId"/>
                    </if>
                    <if condition="!emailContactMechId &amp;&amp; emailAddress">
                        <service-call name="mantle.party.ContactServices.create#EmailAddress" out-map="emOut"
                                in-map="context + [contactMechPurposeId:emailContactMechPurposeId]"/>
                        <set field="emailContactMechId" from="emOut.contactMechId"/>
                    </if>
                </else></if>

                <set field="firstNameOnAccount" from="firstName"/>
                <set field="lastNameOnAccount" from="lastName"/>
                <set field="gatewayCimId" from="paymentIntentResponseMap.payment_method"/>

                <if condition="paymentMethodId"><then>
                    <service-call name="update#mantle.account.method.PaymentMethod" out-map="context"
                            in-map="context+[ownerPartyId:orderPart.customerPartyId]"/>
                </then><else>
                    <service-call name="create#mantle.account.method.PaymentMethod" out-map="context"
                            in-map="context+[ownerPartyId:orderPart.customerPartyId]"/>
                </else></if>

                <!-- If there is an error in the stripe checkout a postal contact mech may not be created -->
                <if condition="postalContactMechId">
                    <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="postalContactMech"
                            auto-field-map="[contactMechId:postalContactMechId]" for-update="true"/>
                    <!-- this is verified through stripe see: https://stripe.com/resources/more/what-is-address-verification-service#how-to-start-using-address-verification-service and https://docs.stripe.com/disputes/prevention/verification -->
                    <service-call name="update#mantle.party.contact.ContactMech" in-map="[contactMechId:postalContactMechId,trustLevelEnumId:'CmtlVerified']"/>
                </if>

                <if condition="origPaymentMethodId &amp;&amp; origPaymentMethodId != paymentMethodId">
                    <!-- update Payment.paymentMethodId and .toPaymentMethodId on open Payment records -->
                    <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                        <econdition field-name="paymentMethodId" from="origPaymentMethodId"/>
                        <econdition field-name="statusId" operator="in" value="PmntProposed,PmntPromised,PmntAuthorized,PmntDeclined"/>
                        <econdition field-name="paymentAuthCode" operator="is-null"/>
                    </entity-find>
                    <iterate list="paymentList" entry="payment">
                        <set field="payment.paymentMethodId" from="paymentMethodId"/>
                        <entity-update value-field="payment"/>
                        <message>Updated Payment Method on Payment ${payment.paymentId}</message>
                    </iterate>
                    <entity-find entity-name="mantle.account.payment.Payment" list="toPaymentList">
                        <econdition field-name="toPaymentMethodId" from="origPaymentMethodId"/>
                        <econdition field-name="statusId" operator="in" value="PmntProposed,PmntPromised,PmntAuthorized,PmntDeclined"/>
                    </entity-find>
                    <iterate list="toPaymentList" entry="toPayment">
                        <set field="toPayment.toPaymentMethodId" from="paymentMethodId"/>
                        <entity-update value-field="toPayment"/>
                        <message>Updated To Payment Method on Payment ${toPayment.paymentId}</message>
                    </iterate>
                </if>
            </if>
            <if condition="!paymentMethodId &amp;&amp; !isTest">
                <return type="danger" message="No payment method found for checkout ${messageObject.data.object.id} based on stripe problem."/>
            </if>

            <set field="paymentInstrumentEnumId" value="PiStripe"/>
            <service-call name="mantle.order.OrderServices.add#OrderPartPayment" in-map="[
                        orderId:orderPart.orderId,orderPartSeqId:orderPart.orderPartSeqId,
                        settlementTermId:'Immediate', paymentInstrumentEnumId:paymentInstrumentEnumId,paymentGatewayConfigId:paymentGatewayConfigId,
                        entryDate:ec.user.nowTimestamp, paymentRefNum:messageObject.data.object.payment_intent,paymentMethodId:paymentMethodId]" out-map="context"/>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" auto-field-map="[paymentId:paymentId]" for-update="true"/>
            <!--                <log level="warn" message="handle#Webhook payment.toString() ${payment.toString()}"/>-->

            <entity-find entity-name="mantle.account.method.PaymentGatewayResponse" list="paymentGatewayResponseList">
                <econdition field-name="referenceNum" from="messageObject.id"/>
                <order-by field-name="-transactionDate"/></entity-find>
            <set field="paymentId" from="payment.paymentId"/>
            <set field="paymentMethodId" from="payment.paymentMethodId"/>
            <set field="finAccountId" from="payment.finAccountId"/>
            <set field="amount" from="(messageObject.data.object.amount_total as BigDecimal) / 100"/>
            <set field="amountUomId" from="messageObject.data.object.currency.toUpperCase()"/>
            <set field="transactionDate" from="new Timestamp(messageObject.data.object.created * 1000L)"/>
            <set field="referenceNum" from="messageObject.id"/>
            <set field="altReference" from="messageObject.request.idempotency_key"/>
            <set field="subReference" from="messageObject.data.object.payment_intent"/>
            <service-call name="store#mantle.account.method.PaymentGatewayResponse" out-map="context" in-map="[
                        paymentGatewayResponseId:paymentGatewayResponseList.getFirst()?.paymentGatewayResponseId,
                        paymentGatewayConfigId:paymentGatewayConfigId,
                        paymentOperationEnumId:'PgoAuthAndCapture',
                        paymentId:payment.paymentId,
                        paymentMethodId:payment.paymentMethodId,
                        amount:amount,
                        amountUomId:amountUomId,
                        finAccountId:finAccountId,
                        transactionDate:transactionDate,
                        referenceNum:referenceNum,
                        altReference:altReference,
                        subReference:subReference,
                        resultSuccess:'Y',
                        resultDeclined:'N',
                        resultError:'N',
                        resultBadExpire:'N',
                        resultBadCardNumber:'N']"/>

            <set field="orderId" from="orderPart.orderId"/>
            <set field="orderPartSeqId" from="orderPart.orderPartSeqId"/>
            <entity-find-one entity-name="moqui.service.ServiceRegister" value-field="serviceRegister" auto-field-map="[serviceRegisterId:'StripeCheckoutSuccess']"/>
            <if condition="!serviceRegister || !serviceRegister.serviceName">
                <return error="true" type="danger" message="No service register found for StripeCheckoutSuccess."/>
            </if>
            <service-call name="${serviceRegister.serviceName}" in-map="context"/>
        </actions>
    </service>
    <service verb="consume" noun="CheckoutSessionExpired">
        <implements service="stripe.StripeServices.consume#StripeWebhookEventInterface"/>
        <actions>
            <!-- Get partyId (required for a payment) -->
            <set field="partyId" from="orderPart.customerPartyId"/>
            <if condition="messageObject.data.object.customer">
                <if condition="partyId"><then>
                    <entity-find-one entity-name="mantle.party.PartyIdentification" value-field="partyIdentification"
                            auto-field-map="[partyId:partyId,partyIdTypeEnumId:'PtidSci']" for-update="true"/>
                    <if condition="partyIdentification?.idValue &amp;&amp; partyIdentification.idValue != messageObject.data.object.customer">
                        <set field="partyIdentification.idValue" from="messageObject.data.object.customer"/>
                        <entity-update value-field="partyIdentification"/>
                    </if>
                    <if condition="partyIdentification &amp;&amp; partyIdentification.expireDate &lt;= new Timestamp(System.currentTimeMillis())">
                        <set field="identificationPartyId" from="partyId"/>
                    </if>
                </then><else>
                    <entity-find entity-name="mantle.party.PartyIdentification" list="partyIdentificationList" limit="1">
                        <econdition field-name="partyIdTypeEnumId" value="PtidSci"/>
                        <econdition field-name="idValue" from="messageObject.data.object.customer"/>
                        <econdition field-name="expireDate" operator="less-equals" from="new Timestamp(System.currentTimeMillis())"/>
                        <order-by field-name="-lastUpdatedStamp"/>
                    </entity-find>
                    <set field="identificationPartyId" from="partyIdentificationList.getFirst()?.partyId"/>
                </else></if>
                <if condition="identificationPartyId &amp;&amp; partyId &amp;&amp; identificationPartyId != partyId">
                    <log level="warn" message="A partyId was found for the customer ${messageObject.data.object.customer} but it is not the same as the orderPart.customerPartyId ${partyId}"/>
                </if>
                <if condition="!partyId &amp;&amp; identificationPartyId">
                    <set field="partyId" from="identificationPartyId"/>
                </if>
            </if>
            <if condition="partyId &amp;&amp; !identificationPartyId">
                <service-call name="store#mantle.party.PartyIdentification" in-map="[partyId:partyId,
                        partyIdTypeEnumId:'PtidSci',idValue:messageObject.data.object.customer]"/>
            </if>
            <!-- RIP: https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/ -->
            <!-- TODO: Consider using https://github.com/tupilabs/HumanNameParser.java/tree/master or something like: https://www.nameapi.org/en/demos/name-parser/ -->
            <set field="fullName" from="messageObject.data.object.customer_details?.name"/>
            <set field="matcher" from="(fullName =~ /(\S+)\s+(.*)/)"/>
            <if condition="matcher.matches()"><then>
                <set field="firstName" from="matcher[0][1] ?: fullName"/>
                <set field="lastName" from="matcher[0][2] ?: fullName"/>
            </then><else>
                <set field="firstName" from="fullName"/>
                <set field="lastName" from="fullName"/>
            </else></if>
            <if condition="!firstName || !lastName">
                <set field="firstName" value="No"/>
                <set field="lastName" value="Name"/>
            </if>
            <if condition="!partyId &amp;&amp; messageObject.data.object.customer_details != null">
                <!--                    <log level="warn" message="handle#Webhook fullName ${fullName} firstName ${firstName} lastName ${lastName}"/>-->
                <if condition="messageObject.data.object.customer_details?.address?.country">
                    <entity-find entity-name="moqui.basic.Geo" list="countryGeoList" limit="1" cache="true">
                        <econdition field-name="geoCodeAlpha2" from="messageObject.data.object.customer_details?.address.country"/>
                    </entity-find>
                </if>
                <service-call name="mantle.party.PartyServices.create#PersonCustomer" in-map="[createUserAccount:false,
                            emailAddress:messageObject.data.object.customer_details?.email,
                            firstName:firstName,
                            lastName:lastName,
                        ]" out-map="context"/>
            </if>
            <if condition="!orderPart.customerPartyId">
                <set field="orderPart.customerPartyId" from="partyId"/>
                <entity-update value-field="orderPart"/>
            </if>

            <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="postalContactMech"
                    auto-field-map="[contactMechId:postalContactMechId]" for-update="true"/>
            <!-- If there is an error in the stripe checkout a postal contact mech may not be created -->
            <if condition="postalContactMech">
                <!-- this is verified through stripe see: https://stripe.com/resources/more/what-is-address-verification-service#how-to-start-using-address-verification-service and https://docs.stripe.com/disputes/prevention/verification -->
                <set field="postalContactMech.trustLevelEnumId" value="CmtlVerified"/>
                <entity-update value-field="postalContactMech"/>
            </if>

            <if condition="!paymentMethodId &amp;&amp; messageObject.data.object.customer_details != null">
                <if condition="!messageObject.data.object.payment_intent"><then>
                    <log level="warn" message="No payment intent found for checkout ${messageObject.data.object.id}."/>
                </then><else>
                    <script><![CDATA[
                        org.moqui.util.RestClient paymentIntentRestClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                                .basicAuth(systemMessage.remote.privateKey,"")
                        def paymentIntentUriBuilder = paymentIntentRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                                .path("/v1/payment_intents/${messageObject.data.object.payment_intent}")
                        paymentIntentUriBuilder.build()

                        org.moqui.util.RestClient.RestResponse paymentIntentRestResponse = paymentIntentRestClient.call()
                        context.paymentIntentResponseMap = (Map) paymentIntentRestResponse.jsonObject()
                        if (paymentIntentRestResponse.statusCode < 200 || paymentIntentRestResponse.statusCode >= 300) {
                            ec.logger.warn("Could not get payment intent")
                            throw new org.moqui.BaseException("Got status code ${paymentIntentRestResponse.statusCode} from Stripe on a get payment intent for the parameter '${paymentIntentResponseMap.error.type}' and message '${paymentIntentResponseMap.error.message}'")
                            return
                        }
                        ]]></script>
                    <if condition="paymentIntentResponseMap.customer &amp;&amp; messageObject.data.object.customer &amp;&amp; paymentIntentResponseMap.customer != messageObject.data.object.customer">
                        <return type="danger" error="true" message="The customer on the payment intent ${paymentIntentResponseMap.customer} does not match the customer on the checkout session ${messageObject.data.object.customer}."/>
                    </if>

                    <entity-find entity-name="mantle.account.method.PaymentMethod" list="paymentMethodList" for-update="true">
                        <econdition field-name="ownerPartyId" from="orderPart.customerPartyId"/>
                        <econdition field-name="gatewayCimId" from="paymentIntentResponseMap.payment_method"/>
                        <econdition field-name="paymentGatewayConfigId"/>
                        <date-filter/></entity-find>

                    <set field="paymentMethod" from="paymentMethodList.getFirst()"/>
                    <set field="paymentMethodId" from="paymentMethod?.paymentMethodId"/>
                    <set field="origPaymentMethodId" from="paymentMethodId"/>
                    <set field="postalContactMechId" from="paymentMethod?.postalContactMechId"/>
                    <set field="telecomContactMechId" from="paymentMethod?.telecomContactMechId"/>
                    <set field="emailContactMechId" from="paymentMethod?.emailContactMechId"/>
                    <set field="paymentMethodTypeEnumId" value="PmtStripe"/>

                    <set field="emailAddress" from="messageObject.data.object.customer_details?.email"/>

                    <set field="toName" from="messageObject.data.object.customer_details?.name"/>
                    <set field="city" from="messageObject.data.object.customer_details?.address?.city"/>
                    <set field="countryGeoId" from="countryGeoList?.getFirst()?.geoId"/>
                    <set field="address1" from="messageObject.data.object.customer_details?.address?.line1?:' '"/>
                    <set field="address2" from="messageObject.data.object.customer_details?.address?.line2"/>
                    <set field="postalCode" from="messageObject.data.object.customer_details?.address?.postal_code"/>
                    <log level="warn" message="handle#Webhook messageObject.data.object.customer_details?.address?.state ${messageObject.data.object.customer_details?.address?.state}"/>
                    <if condition="messageObject.data.object.customer_details?.address?.state">
                        <entity-find entity-name="moqui.basic.Geo" list="stateGeoList" cache="true">
                            <econdition field-name="geoCodeAlpha2" from="messageObject.data.object.customer_details?.address?.state"/>
                        </entity-find>
                        <if condition="stateGeoList.size() &gt; 1">
                            <then>
                                <entity-find entity-name="moqui.basic.GeoAssoc" list="stateGeoAssocList" cache="true">
                                    <econdition field-name="geoId" from="countryGeoId"/>
                                    <econdition field-name="toGeoId" operator="in" from="stateGeoList*.geoId"/>
                                </entity-find>
                                <set field="stateProvinceGeoId" from="stateGeoAssocList?.getFirst()?.toGeoId"/>
                            </then>
                            <else>
                                <set field="stateProvinceGeoId" from="stateGeoList?.getFirst()?.geoId"/>
                            </else>
                        </if>
                    </if>

                    <set field="contactNumber" from="messageObject.data.object.customer_details?.phone"/>

                    <set field="postalContactMechPurposeId" value="PostalBilling"/>
                    <set field="telecomContactMechPurposeId" value="PhoneBilling"/>
                    <set field="emailContactMechPurposeId" value="EmailBilling"/>
                    <set field="fromDate" from="new Timestamp(System.currentTimeMillis())"/>

                    <set field="trustLevelEnumId" value="CmtlVerified"/>

                    <if condition="paymentMethodId"><then>
                        <!-- if update (paymentMethodId) and main field for type specified then update it -->
                        <service-call name="mantle.party.ContactServices.store#PartyContactInfo" in-map="context" out-map="context"/>
                    </then><else>
                        <!-- if create (!paymentMethodId) and *ContactMechId just use it, otherwise create contact mech -->
                        <if condition="!postalContactMechId &amp;&amp; address1">
                            <service-call name="mantle.party.ContactServices.create#PostalAddress" out-map="paOut"
                                    in-map="context + [contactMechPurposeId:postalContactMechPurposeId]"/>
                            <set field="postalContactMechId" from="paOut.contactMechId"/>
                        </if>
                        <if condition="!telecomContactMechId &amp;&amp; contactNumber">
                            <service-call name="mantle.party.ContactServices.create#TelecomNumber" out-map="tnOut"
                                    in-map="context + [contactMechPurposeId:telecomContactMechPurposeId]"/>
                            <set field="telecomContactMechId" from="tnOut.contactMechId"/>
                        </if>
                        <if condition="!emailContactMechId &amp;&amp; emailAddress">
                            <service-call name="mantle.party.ContactServices.create#EmailAddress" out-map="emOut"
                                    in-map="context + [contactMechPurposeId:emailContactMechPurposeId]"/>
                            <set field="emailContactMechId" from="emOut.contactMechId"/>
                        </if>
                    </else></if>

                    <set field="firstNameOnAccount" from="firstName"/>
                    <set field="lastNameOnAccount" from="lastName"/>
                    <set field="gatewayCimId" from="paymentIntentResponseMap.payment_method"/>

                    <if condition="paymentMethodId"><then>
                        <service-call name="update#mantle.account.method.PaymentMethod" out-map="context"
                                in-map="context+[ownerPartyId:orderPart.customerPartyId]"/>
                    </then><else>
                        <service-call name="create#mantle.account.method.PaymentMethod" out-map="context"
                                in-map="context+[ownerPartyId:orderPart.customerPartyId]"/>
                    </else></if>

                    <!-- If there is an error in the stripe checkout a postal contact mech may not be created -->
                    <if condition="postalContactMechId">
                        <entity-find-one entity-name="mantle.party.contact.ContactMech" value-field="postalContactMech"
                                auto-field-map="[contactMechId:postalContactMechId]" for-update="true"/>
                        <!-- this is verified through stripe see: https://stripe.com/resources/more/what-is-address-verification-service#how-to-start-using-address-verification-service and https://docs.stripe.com/disputes/prevention/verification -->
                        <service-call name="update#mantle.party.contact.ContactMech" in-map="[contactMechId:postalContactMechId,trustLevelEnumId:'CmtlVerified']"/>
                    </if>

                    <if condition="origPaymentMethodId &amp;&amp; origPaymentMethodId != paymentMethodId">
                        <!-- update Payment.paymentMethodId and .toPaymentMethodId on open Payment records -->
                        <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                            <econdition field-name="paymentMethodId" from="origPaymentMethodId"/>
                            <econdition field-name="statusId" operator="in" value="PmntProposed,PmntPromised,PmntAuthorized,PmntDeclined"/>
                            <econdition field-name="paymentAuthCode" operator="is-null"/>
                        </entity-find>
                        <iterate list="paymentList" entry="payment">
                            <set field="payment.paymentMethodId" from="paymentMethodId"/>
                            <entity-update value-field="payment"/>
                            <message>Updated Payment Method on Payment ${payment.paymentId}</message>
                        </iterate>
                        <entity-find entity-name="mantle.account.payment.Payment" list="toPaymentList">
                            <econdition field-name="toPaymentMethodId" from="origPaymentMethodId"/>
                            <econdition field-name="statusId" operator="in" value="PmntProposed,PmntPromised,PmntAuthorized,PmntDeclined"/>
                        </entity-find>
                        <iterate list="toPaymentList" entry="toPayment">
                            <set field="toPayment.toPaymentMethodId" from="paymentMethodId"/>
                            <entity-update value-field="toPayment"/>
                            <message>Updated To Payment Method on Payment ${toPayment.paymentId}</message>
                        </iterate>
                    </if>
                </else></if>
            </if>

            <if condition="partyId &amp;&amp; paymentMethodId">
                <service-call name="mantle.order.OrderServices.add#OrderPartPayment" in-map="[
                            orderId:orderPart.orderId,orderPartSeqId:orderPart.orderPartSeqId,
                            settlementTermId:'Immediate', paymentInstrumentEnumId:'PiStripe',paymentGatewayConfigId:paymentGatewayConfigId,
                            entryDate:ec.user.nowTimestamp, paymentRefNum:messageObject.data.object.payment_intent,paymentMethodId:paymentMethodId]" out-map="context"/>
                <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" auto-field-map="[paymentId:paymentId]" for-update="true"/>
            </if>
            <!--                <log level="warn" message="handle#Webhook payment.toString() ${payment.toString()}"/>-->

            <entity-find entity-name="mantle.account.method.PaymentGatewayResponse" list="paymentGatewayResponseList">
                <econdition field-name="referenceNum" from="messageObject.id"/>
                <order-by field-name="-transactionDate"/></entity-find>
            <set field="paymentId" from="payment?.paymentId"/>
            <set field="paymentMethodId" from="payment?.paymentMethodId"/>
            <set field="finAccountId" from="payment?.finAccountId"/>
            <set field="amount" from="(messageObject.data.object.amount_total as BigDecimal) / 100"/>
            <set field="amountUomId" from="messageObject.data.object.currency.toUpperCase()"/>
            <set field="transactionDate" from="new Timestamp(messageObject.data.object.created * 1000L)"/>
            <set field="referenceNum" from="messageObject.id"/>
            <set field="altReference" from="messageObject.request.idempotency_key"/>
            <set field="subReference" from="messageObject.data.object.payment_intent"/>
            <service-call name="store#mantle.account.method.PaymentGatewayResponse" out-map="context" in-map="[
                        paymentGatewayResponseId:paymentGatewayResponseList.getFirst()?.paymentGatewayResponseId,
                        paymentGatewayConfigId:paymentGatewayConfigId,
                        paymentOperationEnumId:'PgoRelease',
                        paymentId:paymentId,
                        paymentMethodId:paymentMethodId,
                        amount:amount,
                        amountUomId:amountUomId,
                        finAccountId:finAccountId,
                        transactionDate:transactionDate,
                        referenceNum:referenceNum,
                        altReference:altReference,
                        subReference:subReference,
                        resultSuccess:'N',
                        resultDeclined:'Y',
                        resultError:'N',
                        resultBadExpire:'N',
                        resultBadCardNumber:'N']"/>

            <if condition="payment">
                <set field="payment.statusId" value="PmntCancelled"/>
                <entity-update value-field="payment"/>
            </if>

            <set field="orderId" from="orderPart.orderId"/>
            <set field="orderPartSeqId" from="orderPart.orderPartSeqId"/>
            <entity-find-one entity-name="moqui.service.ServiceRegister" value-field="serviceRegister" auto-field-map="[serviceRegisterId:'StripeCheckoutExpired']"/>
            <if condition="!serviceRegister || !serviceRegister.serviceName">
                <return error="true" type="danger" message="No service register found for StripeCheckoutExpired."/>
            </if>
            <service-call name="${serviceRegister.serviceName}" in-map="context"/>
        </actions>
    </service>

    <service verb="reject" noun="OrderPart">
        <in-parameters>
            <parameter name="orderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="orderPart" type="Map"/>
        </in-parameters>
        <actions>
            <if condition="!orderPart">
                <entity-find-one entity-name="mantle.order.OrderPart" value-field="orderPart" auto-field-map="[orderId:orderId,orderPartSeqId:orderPartSeqId]"/>
            </if>
            <if condition="!orderPart">
                <return message="OrderPart not found for orderId ${orderId} and orderPartSeqId ${orderPartSeqId}."/>
            </if>
            <if condition="orderPart.statusId != 'OrderRejected' &amp;&amp; orderPart.statusId != 'OrderCancelled'">
                <service-call name="mantle.order.OrderServices.reject#OrderPart" in-map="[orderId:orderPart.orderId,orderPartSeqId:orderPart.orderPartSeqId]"/>
            </if>
        </actions>
    </service>

    <service verb="authorizeAndCapture" noun="Payment">
        <implements service="mantle.account.PaymentServices.authorize#Payment"/>
        <actions>
            <entity-find entity-name="mantle.account.method.PaymentGatewayResponse" list="paymentGatewayResponseList">
                <econdition field-name="paymentId"/>
                <econdition field-name="paymentGatewayConfigId"/>
                <econdition field-name="paymentOperationEnumId" value="PgoAuthAndCapture"/>
                <order-by field-name="-transactionDate"/></entity-find>

            <if condition="paymentGatewayResponseList.size() == 0">
                <return error="true" type="danger" message="No payment gateway response found for payment."/>
            </if>
            <if condition="paymentGatewayResponseList.size() &gt; 1">
                <log level="warn" message="Multiple payment gateway responses found for payment."/>
            </if>

            <set field="paymentGatewayResponseId" from="paymentGatewayResponseList.getFirst().paymentGatewayResponseId"/>
        </actions>
    </service>

    <!-- Not tested and partially done    <service verb="create" noun="CheckoutFromPayment">
        <description>Create a Stripe Checkout Session to capture a Payment.

If the payment has an OrderPart with OrderItems attached, the OrderItems will be listed (including discounts and taxes [if setup]).

Otherwise, the payment unapplied total will be listed.</description>
        <in-parameters>
            <parameter name="paymentId" required="true"/>
            <parameter name="successUrl" required="true" default-value="${ec.web.getWebappRootUrl(false,true)}"/>
        </in-parameters>
        <out-parameters>

        </out-parameters>
        <actions>
            <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment" auto-field-map="[
                paymentId:paymentId]"/>
            <if condition="!payment">
                <return error="true" type="danger" message="No payment found for paymentId ${paymentId}."/>
            </if>
            <entity-find-one entity-name="mantle.account.method.PaymentGatewayConfig" value-field="paymentGateway"
                    auto-field-map="[paymentGatewayConfigId:payment.paymentGatewayConfigId]" cache="true"/>
            <if condition="!paymentGateway">
                <return error="true" type="danger" message="No payment gateway found for paymentId ${paymentId}."/>
            </if>

            <set field="stripeMap" from="[success_url:successUrl,mode:'payment',line_items:[]]"/>
            <if condition="payment.orderId"><then>
                <entity-find entity-name="mantle.order.OrderItem" list="orderItemList">
                    <econdition field-name="orderId" from="payment.orderId"/>
                    <econdition field-name="orderPartSeqId" from="payment.orderPartSeqId" ignore-if-empty="true"/>
                    <econdition field-name="orderItemSeqId" from="payment.orderItemSeqId" ignore-if-empty="true"/>
                    <econdition field-name="parentItemSeqId" operator="is-null"/>
                    <order-by field-name="orderPartSeqId,orderItemSeqId"/>
                    --><!-- NOTE: quite a few fields always selected, necessary for calculated values, etc -->
    <!-- just select all by not specifying any fields to select:
    <select-field field-name="orderId,orderItemSeqId,orderPartSeqId,parentItemSeqId,itemTypeEnumId,productId"/>
    <select-field field-name="quantity,selectedAmount,unitAmount,unitListPrice,isPromo"/>
    --><!--
                </entity-find>
                <set field="topItemSeqIds" from="orderItemList*.orderItemSeqId"/>
                <if condition="topItemSeqIds">
                    <entity-find entity-name="mantle.order.OrderItem" list="childOrderItemList">
                        <econdition field-name="orderId" from="payment.orderId"/>
                        <econdition field-name="orderPartSeqId" from="payment.orderPartSeqId" ignore-if-empty="true"/>
                        <econdition field-name="orderItemSeqId" from="payment.orderItemSeqId" ignore-if-empty="true"/>
                        <econdition field-name="parentItemSeqId" operator="in" from="topItemSeqIds"/>
                        <order-by field-name="orderItemSeqId"/>
                    </entity-find>
                    <set field="orderPartIdDoneList" from="[]"/>
                    <script><![CDATA[
                        // NOTE: must use orderItemList.size() on each iteration as EntityList size will change with child items added
                        for (int oiIdx = 0; oiIdx < orderItemList.size(); oiIdx++) {
                            context.orderItem = (Map) orderItemList.get(oiIdx)
                            String orderItemSeqId = orderItem.orderItemSeqId
                            List childList = childOrderItemList.findAll({ orderItemSeqId.equals(it.parentItemSeqId) })
                            Map<String, Object> orderItemTotalOut = ec.service.sync.name("mantle.order.OrderServices.get#OrderItemTotal")
                                .parameters([orderItem:orderItem, getChildrenTotals:false]).call()
                            stripeMap.line_items.addAll([quantity:(Integer)orderItemTotalOut.combinedQuantity,price_data:
                                    [currency:'usd',unit_amount_decimal:orderItemTotalOut.combinedAmount*100,product_data:
                                            [name:orderItem.itemDescription]]])
                            for (int cIdx = 0; cIdx < childList.size(); cIdx++) {
                                Map childItem = (Map) childList.get(cIdx)
                                oiIdx++
                                Map<String, Object> childItemTotalOut = ec.service.sync.name("mantle.order.OrderServices.get#OrderItemTotal")
                                    .parameters([orderItem:childItem, getChildrenTotals:false]).call()
                                stripeMap.line_items.addAll([quantity:(Integer)childItemTotalOut.combinedQuantity,price_data:
                                        [currency:'usd',unit_amount_decimal:childItemTotalOut.combinedAmount*100,product_data:
                                                [name:childItem.itemDescription]]])
                            }
                        }
                        ]]></script>

                </if>
            </then><else>
                <set field="stripeMap.line_items" from="stripeMap.line_items + [quantity:1,price_data:
                                        [currency:payment.amountUomId.toLowerCase(),unit_amount_decimal:payment.unappliedTotal*100,product_data:
                                                [name:payment.comments ?: 'Payment ${paymentId}']]]"/>
            </else></if>

            <if condition="stripeMap.line_items*.unit_amount_decimal.sum() != payment.unappliedTotal*100">
                <return error="true" type="danger" message="The sum of the line items does not match the payment unapplied total."/>
            </if>

--><!--            <log level="warn" message="stripeMap: ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(stripeMap))}"/>-->
    <!--            <set field="stripeOutMap" from="flattenNestedMapWithKeys(stripeMap)"/>-->
    <!--            <log level="warn" message="stripeOutMap: ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(stripeOutMap))}"/>--><!--

            <entity-find-one entity-name="mantle.account.method.PaymentGatewayConfig" value-field="paymentGateway" auto-field-map="[paymentGatewayConfigId:paymentGatewayConfigId]"/>
            <set field="stripeRemote" from="paymentGateway.remote"/>

            <script>import org.moqui.util.RestClient</script>
            <script><![CDATA[
                org.moqui.util.RestClient customerRestClient = ec.service.rest().method(org.moqui.util.RestClient.POST)
                        .basicAuth(stripeRemote.privateKey,"")
                        .addBodyParameters(stripeOutMap)
                def customerUriBuilder = customerRestClient.uri().protocol("https").host("api.stripe.com").port(443)
                        .path("/v1/checkout/sessions")
                customerUriBuilder.build()

                org.moqui.util.RestClient.RestResponse customerRestResponse = customerRestClient.call()
                customerResponseMap = (Map) customerRestResponse.jsonObject()
                ec.logger.warn("customerResponseMap: ${groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(customerResponseMap))}")
//                if (customerRestResponse.statusCode < 200 || customerRestResponse.statusCode >= 300) {
//                    ec.logger.warn("Got status code ${customerRestResponse.statusCode} from Stripe on a create customers request for the parameter '${customerResponseMap.error.type}' and message '${customerResponseMap.error.message}'")
//                    ec.logger.warn("Could not create Customer")
//                    ec.message.addPublic(ec.resource.expand('CoarchyOrgPaymentFailed', null), "warning")
//                    return
//                }
                ]]></script>

        </actions>
    </service>-->

</services>
